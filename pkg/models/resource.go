package models

import "time"

// =============================================================================
// FORGE RESOURCE MODEL
// =============================================================================
// This file defines NBCU's internal resource abstraction layer. The Forge
// Orchestrator uses these models to provide a vendor-agnostic interface for
// managing media resources (cameras, encoders, streams) across multiple
// vendor platforms (Sony, AWS MediaLive, etc.).
//
// Architecture Flow:
// 1. Client sends ForgeResource request to Controller
// 2. Controller validates and stores the ForgeResource
// 3. Provider transforms ForgeResource → Vendor-specific request
// 4. Provider sends request to vendor API
// 5. Provider transforms Vendor response → ResourceStatus
// 6. Controller updates ForgeResource with new status
// =============================================================================

// ForgeResource represents NBCU's internal abstraction of a vendor resource.
// This is the primary data structure that flows through the entire system.
// It follows a Kubernetes-like structure with Spec (desired state) and
// Status (observed state) separation, enabling declarative resource management.
//
// Design Pattern: Spec/Status Separation
// - Spec: What the user wants (immutable after creation, except for updates)
// - Status: What the system observes (updated by the controller/provider)
//
// Example JSON:
//
//	{
//	  "id": "forge-12345",
//	  "type": "camera",
//	  "name": "stadium-cam-1",
//	  "namespace": "prod",
//	  "spec": { "vendor_type": "sony", "resolution": "4K", ... },
//	  "status": { "phase": "Running", "vendor_id": "sony-abc123", ... }
//	}
type ForgeResource struct {
	// ID is a unique identifier generated by the Forge system (UUID format).
	// This ID is used internally and is different from the vendor's device ID.
	ID string `json:"id"`

	// Type categorizes the resource kind. Common types include:
	// - "camera": Physical or virtual camera devices
	// - "encoder": Video encoding hardware/software
	// - "decoder": Video decoding endpoints
	// - "router": Signal routing devices
	// - "recorder": Recording/storage devices
	Type string `json:"type"`

	// Name is a human-readable identifier provided by the user.
	// Must be unique within a namespace. Used for display and reference.
	Name string `json:"name"`

	// Namespace provides logical isolation for resources.
	// Typical values: "prod", "staging", "dev", "test"
	// This allows the same resource names in different environments.
	Namespace string `json:"namespace"`

	// Spec contains the desired state configuration for this resource.
	// This is provided by the user and defines what they want.
	Spec ResourceSpec `json:"spec"`

	// Status contains the observed state from the vendor system.
	// This is updated by the controller after vendor API interactions.
	Status ResourceStatus `json:"status"`

	// CreatedAt records when this resource was first created in Forge.
	// Set once during initial creation and never modified.
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt records the last modification time.
	// Updated whenever Spec or Status changes.
	UpdatedAt time.Time `json:"updated_at"`
}

// =============================================================================
// RESOURCE SPECIFICATION
// =============================================================================
// ResourceSpec defines the desired state of a resource. Users provide this
// configuration when creating or updating resources. The provider layer
// transforms these fields into vendor-specific API calls.
// =============================================================================

// ResourceSpec defines the desired state configuration for a ForgeResource.
// This struct contains all user-configurable options that control how the
// resource should be provisioned and configured in the vendor system.
//
// The spec is designed to be vendor-agnostic at the top level, with
// vendor-specific settings stored in the Config map for flexibility.
type ResourceSpec struct {
	// VendorType specifies which vendor provider should handle this resource.
	// Supported values: "sony", "aws"
	// The controller uses this to route requests to the appropriate provider.
	VendorType string `json:"vendor_type"`

	// Config holds vendor-specific configuration as key-value pairs.
	// This provides flexibility for vendor-specific settings that don't
	// fit into the common fields above.
	// Example: {"sony_model": "HDC-5500", "aws_region": "us-east-1"}
	Config map[string]interface{} `json:"config"`

	// =========================================================================
	// VPCR (Video Production Control Room) REQUIREMENTS
	// =========================================================================
	// The following fields address common video production needs across all
	// vendors. These are normalized fields that the provider layer transforms
	// into vendor-specific parameters.
	// =========================================================================

	// Resolution specifies the output video resolution.
	// Common values: "SD" (480p), "HD" (720p), "FHD" (1080p), "4K" (2160p), "8K" (4320p)
	// The provider transforms this into vendor-specific format codes.
	// Example: Sony might use "3840x2160" while AWS uses "UHD"
	Resolution string `json:"resolution,omitempty"`

	// Bitrate defines the target encoding bitrate in bits per second.
	// This controls video quality vs bandwidth tradeoff.
	// Typical ranges:
	// - SD:  1,000,000 - 3,000,000 (1-3 Mbps)
	// - HD:  3,000,000 - 8,000,000 (3-8 Mbps)
	// - FHD: 6,000,000 - 15,000,000 (6-15 Mbps)
	// - 4K:  15,000,000 - 50,000,000 (15-50 Mbps)
	Bitrate int64 `json:"bitrate,omitempty"`

	// StreamURL is the destination URL for video output streams.
	// Supports multiple protocols:
	// - RTMP: rtmp://server/app/stream_key
	// - SRT:  srt://host:port
	// - RTSP: rtsp://host:port/path
	// - HLS:  https://server/path/playlist.m3u8 (for pull-based delivery)
	StreamURL string `json:"stream_url,omitempty"`

	// FrameRate specifies the frames per second for video output.
	// Common values: 23.976, 24, 25, 29.97, 30, 50, 59.94, 60
	// This affects motion smoothness and bandwidth requirements.
	FrameRate float64 `json:"frame_rate,omitempty"`

	// Codec specifies the video compression codec.
	// Supported values: "H.264", "H.265/HEVC", "AV1", "ProRes", "DNxHD"
	// H.264 is most widely compatible; H.265 offers better compression.
	Codec string `json:"codec,omitempty"`

	// AudioChannels defines the number of audio channels.
	// Common values: 2 (stereo), 6 (5.1 surround), 8 (7.1 surround), 16 (multi-track)
	AudioChannels int `json:"audio_channels,omitempty"`

	// AudioBitrate defines the audio encoding bitrate in bits per second.
	// Typical values: 128000 (128 kbps), 256000 (256 kbps), 320000 (320 kbps)
	AudioBitrate int `json:"audio_bitrate,omitempty"`

	// LatencyMode controls the encoding latency profile.
	// Values: "low" (sub-second, for live interaction),
	//         "normal" (2-5 seconds, balanced),
	//         "high" (10+ seconds, for maximum quality)
	LatencyMode string `json:"latency_mode,omitempty"`

	// RecordingEnabled indicates if the stream should be recorded.
	// When true, the provider should configure recording based on
	// RecordingPath and RetentionDays settings.
	RecordingEnabled bool `json:"recording_enabled,omitempty"`

	// RecordingPath specifies where recordings should be stored.
	// Can be a local path or cloud storage URL (s3://bucket/path)
	RecordingPath string `json:"recording_path,omitempty"`

	// RetentionDays specifies how long recordings should be kept.
	// After this period, recordings may be automatically deleted.
	// Value of 0 means indefinite retention.
	RetentionDays int `json:"retention_days,omitempty"`
}

// =============================================================================
// RESOURCE STATUS
// =============================================================================
// ResourceStatus reflects the observed state of the resource as reported by
// the vendor system. This is updated after each vendor API interaction and
// during periodic health checks.
// =============================================================================

// ResourceStatus defines the observed state of a ForgeResource.
// This struct is populated by the provider layer after interacting with
// the vendor API. It provides visibility into the actual state of the
// resource in the vendor system.
//
// Status Lifecycle:
// Pending → Provisioning → Running → (Updating) → Running
//                ↓                        ↓
//             Failed                   Failed
//                ↓                        ↓
//            (Retry)                  (Retry)
type ResourceStatus struct {
	// Phase represents the current lifecycle state of the resource.
	// Valid phases:
	// - "Pending":      Initial state, resource accepted but not yet processed
	// - "Provisioning": Resource is being created in vendor system
	// - "Running":      Resource is active and healthy in vendor system
	// - "Updating":     Resource configuration is being modified
	// - "Deleting":     Resource is being removed from vendor system
	// - "Failed":       Resource operation failed (see Message for details)
	// - "Unknown":      Unable to determine state (connectivity issues)
	Phase string `json:"phase"`

	// Message provides human-readable details about the current status.
	// For failed states, this contains the error message.
	// For running states, this may contain additional info.
	Message string `json:"message"`

	// VendorID is the unique identifier assigned by the vendor system.
	// This is used for subsequent Read/Update/Delete operations.
	// Example: Sony might use "device-12345", AWS uses "arn:aws:..."
	VendorID string `json:"vendor_id"`

	// =========================================================================
	// HEALTH CHECK FIELDS
	// =========================================================================
	// These fields track the health and connectivity status of the resource.
	// They are updated by periodic health check routines.
	// =========================================================================

	// HealthStatus indicates the current health of the resource.
	// Values: "healthy", "degraded", "unhealthy", "unknown"
	// - healthy:   All systems operational
	// - degraded:  Partially functional (e.g., reduced quality)
	// - unhealthy: Resource is not functioning correctly
	// - unknown:   Unable to determine health (check connectivity)
	HealthStatus string `json:"health_status,omitempty"`

	// LastHealthCheck records the timestamp of the most recent health check.
	// Used to determine if health information is stale.
	// If time.Since(LastHealthCheck) > threshold, trigger new check.
	LastHealthCheck time.Time `json:"last_health_check,omitempty"`

	// HealthCheckMessage provides details about the last health check.
	// For degraded/unhealthy states, describes the specific issue.
	// Example: "Video signal lost", "Network latency high (>500ms)"
	HealthCheckMessage string `json:"health_check_message,omitempty"`

	// ConsecutiveFailures tracks the number of consecutive health check failures.
	// Used for alerting thresholds and automatic recovery decisions.
	// Reset to 0 on successful health check.
	ConsecutiveFailures int `json:"consecutive_failures,omitempty"`

	// LastSuccessfulOperation records when the last successful vendor
	// operation occurred (create, update, or health check).
	// Useful for detecting stale/abandoned resources.
	LastSuccessfulOperation time.Time `json:"last_successful_operation,omitempty"`

	// =========================================================================
	// STREAMING METRICS (Real-time Performance Data)
	// =========================================================================
	// These fields provide real-time metrics about streaming performance.
	// Updated during health checks when the resource is actively streaming.
	// =========================================================================

	// CurrentBitrate is the actual measured output bitrate in bps.
	// May differ from Spec.Bitrate due to adaptive bitrate encoding.
	CurrentBitrate int64 `json:"current_bitrate,omitempty"`

	// DroppedFrames is the count of video frames dropped since start.
	// High values indicate encoding/network issues.
	DroppedFrames int64 `json:"dropped_frames,omitempty"`

	// Uptime is the duration the resource has been running.
	// Calculated from when the resource entered "Running" phase.
	Uptime time.Duration `json:"uptime,omitempty"`

	// ConnectionCount tracks active client connections (for output streams).
	// Useful for load monitoring and scaling decisions.
	ConnectionCount int `json:"connection_count,omitempty"`

	// ErrorCount tracks the total errors encountered since resource creation.
	// Includes both vendor API errors and operational errors.
	ErrorCount int `json:"error_count,omitempty"`
}

// =============================================================================
// HELPER METHODS
// =============================================================================

// IsHealthy returns true if the resource is in a healthy operational state.
// A resource is considered healthy if it's Running with healthy status
// or if health status hasn't been checked yet (new resources).
func (s *ResourceStatus) IsHealthy() bool {
	return s.Phase == "Running" && (s.HealthStatus == "healthy" || s.HealthStatus == "")
}

// IsFailed returns true if the resource is in a failed state.
func (s *ResourceStatus) IsFailed() bool {
	return s.Phase == "Failed"
}

// IsTerminal returns true if the resource is in a terminal state
// that requires manual intervention or recreation.
func (s *ResourceStatus) IsTerminal() bool {
	return s.Phase == "Failed" && s.ConsecutiveFailures >= 3
}

// NeedsHealthCheck returns true if a health check should be performed.
// Health checks are needed if:
// - Never checked before (zero time)
// - Last check was more than 30 seconds ago
// - Resource is in unknown state
func (s *ResourceStatus) NeedsHealthCheck() bool {
	if s.LastHealthCheck.IsZero() {
		return true
	}
	if s.HealthStatus == "unknown" {
		return true
	}
	return time.Since(s.LastHealthCheck) > 30*time.Second
}

// SetHealthy updates the status to indicate a healthy state.
func (s *ResourceStatus) SetHealthy(message string) {
	s.HealthStatus = "healthy"
	s.HealthCheckMessage = message
	s.LastHealthCheck = time.Now()
	s.ConsecutiveFailures = 0
	s.LastSuccessfulOperation = time.Now()
}

// SetUnhealthy updates the status to indicate an unhealthy state.
func (s *ResourceStatus) SetUnhealthy(message string) {
	s.HealthStatus = "unhealthy"
	s.HealthCheckMessage = message
	s.LastHealthCheck = time.Now()
	s.ConsecutiveFailures++
	s.ErrorCount++
}
